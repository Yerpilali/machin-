/*----------------------------------------------------------------------------------------------------------------------------------------
**Проект: "Удаленный контроль за скоростью мигания светодиодов".
**Назначение программы: псевдопараллельное выполнение двух задач:
**																									* мигание светодиодов;
**																									* математический расчет с выводом в терминале PuTTY, и работа функции отладчика;
**Разработчик: Нестеров Даниил Александрович - 1191б
**Цель: создание программы, использующей внутренние прерывания микроконтроллера STM32F072RBT 
**Решаемые задачи:
**		1. Реализация функции-обработчика внутреннего прерывания микроконтроллера STM32F072RBT (USART);
**		2. Конфигурирование NVIC;
**		3. Настройка модуля USART на генерацию сигнала прерывания при возникновении заданных событий;
**		4. Реализация функции отладчика
**----------------------------------------------------------------------------------------------------------------------------------------*/
#include "main.h"																							//
																															//
static  int32_t counter;																			// 	Счетчик итераций для вывода в терминал
static	int32_t a = -9;																				//	Начальное значение члена геометрической прогрессии
static	int32_t quotient = 4;																  //	Переменная коэфициента для геометрической прогрессии
static	int32_t sum = -9;																			//	Начальное значение произведения членов прогрессии
static uint8_t flag;																					//	Флаг для проверки нажатой кнопки
static uint8_t flagF = 0;																			//	Флаг для проверки нажатия F5
																															//
int main()																										//
{																															//
	__disable_irq();																						//	Глобальное запрещение прерываний
																															//	Настройка порта GPIOB для контроля светодиода
	RCC->AHBENR|=RCC_AHBENR_GPIOBEN;														//	Включение тактирования порта В
	GPIOB->MODER|= GPIO_MODER_MODER0_0 | GPIO_MODER_MODER8_0; 	//	Переключение линий 0 и 8 порта В в режим "Output"
	GPIOB->MODER&=~ (GPIO_MODER_MODER12 | GPIO_MODER_MODER13);	//	Переключение линий 12(SW4) и 13(SW3) порта В в режим "Input"
	GPIOB->ODR|=0x100;																					//	Разрешение работы светодиодов на стенде CТМ_01 с помощью установки логической "1" на выводе РВ.8									
																															//
	InitUSART1();																								//	Инициализация модуля USART1
	NVIC->ISER[0] |= 0x08000000; 																//	Разрешение в NVIC прерывания от модуля USART1 	
	__enable_irq();																							//	Глобальное разрешение прерываний 
	while(1){																										//
		for (int32_t i = 1; i <=8; i++){													//	Счетчик для итераций
			counter = i;																						//	Приравнивание глобальной переменной к локальной перменной цикла
			a = geom(a, quotient, i);																//	Выполнение одной итерации геометррической прогрессии
			sum = sum * a;																					//	Перемножение членов прогрессии 
			debug();																								//	Вызов функции отладчика
			if (i == 8){																						//	Когда цикл закончивается, значения для текущего члена и произведения членов прогрессии устанавливаются в значения по умолчанию
				a = -9;																								//
				sum = -9;																							//
			}																												//
		}																													//
	}																														//
}																															//
void InitUSART1(){																						//	
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;												//	Включение тактирования USART1
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;													//	Включение тактирования порта А
																															//
																															//	Настройка линий порта А: РА9(ТХ_1) - выход передатчика; PA10(RX_1) - вход приёмника
	GPIOA->MODER |= 0x00280000;																	//	Перевести линии РА9 и РА10 в режим альтернативной функции
	GPIOA->AFR[1] |= 0x00000110;																//	Включить на линиях РА9 и РА10 альтернативную функцию AF1
																															//
																															//	Настройка линии передатчика Тх (РА9)
	GPIOA->OTYPER &= ~GPIO_OTYPER_OT_9;													//	Сбросить 9 бит GPIOA->OTYPER - переключение в режим push-pull для линии РА9 (активный выход) 
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR9;													//	Отключение подтягивающих резисторов для линии РА9 
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEEDR9;										//	Установка высокой скорости синхронизации линии РА9
																															//
																															//	Настройка линии приемника Rx (РА10)
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR10;												//	Сброс режима подтягивающих резисторов для линии РА10
	GPIOA->PUPDR |= GPIO_PUPDR_PUPDR10_0;												//	Включение подтягивающего резистора pull-up на входной линии РА10 (вход приемника Rx)
																															//
																															//	Конфигурирование USART
	USART1->CR1 &= ~USART_CR1_UE;																//	Запрещение работы модуля USART1 для изменения параметров его конфигурации
	USART1->BRR=69;																							//	Настройка делителя частоты, тактирующего USART и задающего скорость приема и передачи данных на уровне 115200 бит/с: 
																															//	Частота тактирующего генератора = 8 МГц 
																															//	Скорость обмена по USART - 115200 бит/с; коэффициент деления - 8000000 / 115200 - 69,4444(4); Округленное значение - 69
	USART1->CR1 = USART_CR1_TE | USART_CR1_RE;									//	Разрешить работу приемника и передатчика USART. Остальные биты этого регистра сброшены, что обеспечивает: 
																															//	количество бит данных в пакете 8;
																															//	контроль четности - отключен; 
																															//	прерывания по любым флагам USART - запрещены;
																															//	состояние USART - отключен
	USART1->CR1 |= USART_CR1_RXNEIE | USART_CR1_TCIE; 					//	Разрешение (в модуле USART1) на выдачу сигнала прерывания при возникновении событий:
																															//	прием кадра в буферный регистр; завершение передачи кадра
	USART1->CR2 = 0;																						//	Количество стоповых бит - 1
	USART1->CR3 = 0;																						//	DMA1 - отключен
	USART1->CR1 |= USART_CR1_UE;																//	По завершении конфигурирования USART разрешить его работу (биту UE регистра CR1 присвоить 1)
}																															//
																															//
																															//
void debug(){																									//	Функция отладчик
	while(1){																										//
		if(flag == 1){																						//	Если нажата F5
			flag = 0;																								//
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	Переход на новую строку со сдвигом каретки 
			USART1->TDR = 0x0D;																			//
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			USART1->TDR = 0x0A;																			//
			break;																									//	Выход из цикла = завершение функции
		}																													//
		if(flag == 2){																						//	Если нажат i
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			USART1->TDR = 0x6E;																			//
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	Вывод сообщения "n=%номер_итерации%"
			USART1->TDR = 0x3D;																			//
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			numToArray(counter);																		//
			flag = 0;																								//	Флаг нажатой кнопки принимает стандартное значение 0
		}																													//
		if(flag == 3){																						//	Если нажата e
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			USART1->TDR = 0x41;																			//
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			USART1->TDR = 0x6E;																			//	Вывод сообщения "an=%текущее_значение_переменной%"
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			USART1->TDR = 0x3D;																			//	
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			numToArray(a);																					//
			flag = 0;																								//	Флаг нажатой кнопки принимает стандартное значение 0
		}																													//
		if(flag == 4){																						//	Если нажата s
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			USART1->TDR = 0x73;																			//
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	Вывод сообщения "s=%произведение_членов_прогрессии""
			USART1->TDR = 0x3D;																			//
			while ((USART1->ISR & USART_ISR_TXE) == 0) {} 					//	
			numToArray(sum);																				//
			flag = 0;																								//	Флаг нажатой кнопки принимает стандартное значение 0
		}																													//
	}																														//
}																															//
																															//
void USART1_IRQHandler(void)																	// Функция обработчик прерываний.
{																															//
	uint16_t pack;																							//
																															//	Событие готовности принятых данных к чтению 
	if (USART1->ISR & USART_ISR_RXNE) { 												//	Если в регистре состояний USART1 установлен флаг "RXNE", то
		pack=(uint8_t)USART1->RDR; 																//	Чтение принятого битового пакета из буферного регистра приемника USART1 
		switch ( pack ) {																					//
		case 0x69:																								//	Если нажата клавиша i
			flag = 2;																								//	флаг flag принимает значение 2
			flagF = 0;																							//	флаг flagF принимает значение 0 
			break;																									//
		case 0x65:																								//	Если нажата клавиша e
			flag = 3;																								//	флаг flag принимает значение 3
			flagF = 0;																							//	флаг flagF принимает значение 0 
			break;																									//
		case 0x73:																								//	Если нажата клавиша s
			flag = 4;																								//	флаг flag принимает значение 4
			flagF = 0;																							//	флаг flagF принимает значение 0 
			break;																									//
																															//	Начало обработки нажатия на F5
		case 27:																									//	Если принят пакет 027
			flagF = 1;																							//	флаг flagF принимает значение 1
			break;																									//
		case 91:																									//	Если вторым принят пакет 091
			if (flagF == 1){																				//  и флаг flagF в значении 1
				flagF = 2;																						//	flagF принимает значение 2
			}																												//	
			break;																									//
		case 49:																									//	Если третьим принят пакет 049
			if (flagF == 2){																				//	и флаг flagF в значении 2
				flagF = 3;																						//	flagF принимает значение 3
			}																												//
			break;																									//
		case 53:																									//	Если четвертым принят пакет 053
			if (flagF == 3){																				//	и флаг flagF в значении 3
				flagF = 4;																						//	flagF принимает значение 4
			}																												//
			break;																									//
		case 126:																									//	Если пятым принят пакет 126
			if (flagF == 4){																				//	и флаг flagF в значении 4
				flagF = 0;																						//	flagF принимает стандартное значение 0
				flag = 1;																							//	флаг flag принимает значение 1, что соответсвует нажатой f5
			}																												//
			break;																									//
		default:																									//
			flagF = 0;																							//	Если приянт любой другой пакет, то flagF становится в начальное положение
			break;																									//
		}																													//
																															//	Конец обработки нажатия на F5
	}																														//
																															//
																															//	Событие завершение передачи битового пакета 
	if (USART1->ISR & USART_ISR_TC) {														//	Если в регистре состояний USART1 установлен флаг "ТС", то
																															//	Сброс флага завершения передачи кадра 
		USART1->ICR=USART_ICR_TCCF;																//	Сбросить флаг завершения передачи кадра, чтобы прерывание не сработало повторно
	}																														//
}																															//
																															//
																															//
int32_t geom(int32_t an, int32_t q, int32_t n){								//	Функция расчета геометрической прогресии
	if (n == 1){																								//	Если итерация первая
		return an;																								//		возвращается первый член прогрессии
	}																														//
	else{																												//	Иначе
		return q*an;																							//		просиходит умножение коэффициента на переменную
	}																														//
}																															//
																															//
void numToArray(int32_t num){																	//	Функция вывода числа в терминал PuTTY
	int32_t count = 0;																					//	Переменная, отвечающая за размер числа 
	int32_t n = 10;																							//	Переменная, для определения размера числа
	int32_t temp;																								//	Временная переменная
																															//
	if (num < 0){																								//	Если число отрицательное
		num = num * (-1);																					//	То число умножаем на -1
		while ((USART1->ISR & USART_ISR_TXE) == 0) {}							//
		USART1->TDR = 0x2d;  																			//	И выводим перед выводом числа знак минус				
	}																														//
	while (num!=0){																							//	Пока число не равное 0
		if (num > n){																							//	Получаем размер числа, пока num больше числа
			n *= 10;																								//	увеличиваем n на 1 порядок
			count +=1;																							//	и увеличиваем переменную размера числа,
		}																													//
		else {																										//	как только переменная стала больше числа,
			n /= 10;																								//	уменьшаем n на 1 порядок
			count -=1;																							//	и уменьшаем переменную размера числа.
			temp = num % n;																					//	Временная переменная приравнивается остатку от деления числа на n
			while ((USART1->ISR & USART_ISR_TXE) == 0) {}						//	
			USART1->TDR = ((num-temp)/n) + 48;											//	В терминал подается пакет, соответвующий цифре текущего разряда. В качестве примера: ((3514-514)/1000) + 48 - в терминал будет выведено 3
			num = temp;																							//	Уменьшаем количество разрядов в числе, присваивая переменной числа значение временной переменной
		}																													//
	}																														//
	while ((USART1->ISR & USART_ISR_TXE) == 0) {}								//	Переход на новую строку со сдвигом каретки
	USART1->TDR = 0xd;																					//
	while ((USART1->ISR & USART_ISR_TXE) == 0) {}								//
	USART1->TDR = 0xa;																					//
}																															//
/*----------------------------------------------------------------------------------------------------------------------------------------
**Руководство пользователя:
**		1. Запустите программу на лабораторном комплексе;
**		2. На компьютере запустите приложение PuTTY и подключитесь к соответствующему COM-порту на скорости 115200 бит/с;
** 		3. При активном окне терминала нажмите: 'i' для вывода текущей итерации;
**																						's' для вывода произведения всех членов прогрессии;
**																						'e'	для вывода текущего члена прогресии;
**																						'f5' для переключения на следующую итерацию
**----------------------------------------------------------------------------------------------------------------------------------------*/
