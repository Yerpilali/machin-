/*----------------------------------------------------------------------------------------------------------------------------------------
**Проект: "Асинхронное управление частотой мигания светодиода".
**Назначение программы: асинхронное управление частотой мигания светодиода из приложения PuTTY
**Разработчик: Нестеров Даниил Александрович - 1191б
**Цель: создание программы, использующей внутренние прерывания микроконтроллера STM32F072RBT для управления частотой мигания светодиода 
**Решаемые задачи:
**		1. Реализация функции-обработчика внутреннего прерывания микроконтроллера STM32F072RBT (USART);
**		2. Конфигурирование NVIC;
**		3. Настройка модуля USART на генерацию сигнала прерывания при вводе частоты мигания и изменение её.
**----------------------------------------------------------------------------------------------------------------------------------------*/

#include "main.h"

static uint8_t buf[256];							 											//Буфер данных, передаваемых на ПК посредством USART
static uint32_t iReadyTX , iCompleteTX ; 										//Количество битовых пакетов готовых для передачи и переденных на ПК соответственно int main ()
static uint32_t delayCountArr[6] = {1, 2, 3, 4, 5, 6};			//Массив задающий задержку
static uint32_t tempDelayArr[6] = {0, 0, 0, 0, 0, 0};				//Массив записывающий входящие данные об задержке
static int8_t count = -1;																		//Количество входящих символов
static uint32_t delayCount = 0;															//Переменная задержки
static uint8_t flag = 0;																		//Метка сигнализирующая о нажатии на enter

int main()
{
	
	__disable_irq();																					//Глобальное запрещение прерываний
	
	//Настройка порта GPIOB для контроля светодиода
	RCC->AHBENR|=RCC_AHBENR_GPIOBEN;													//Включение тактирования порта В
	GPIOB->MODER|= GPIO_MODER_MODER0_0 | GPIO_MODER_MODER8_0; //Переключение линий 0 и 8 порта В в режим "Output"
	GPIOB->MODER&=~ (GPIO_MODER_MODER12 | GPIO_MODER_MODER13);//Переключение линий 12(SW4) и 13(SW3) порта В в режим "Input"
	GPIOB->ODR|=0x100;																				//Разрешение работы светодиодов на стенде CТМ_01 с помощью установки логической "1" на выводе РВ.8									
	//---------------------------------------------
	iReadyTX = 0;																							//Сброс количества битовых пакетов, подготовленных для передачи на ПК
	iCompleteTX = 0;																					//Сброс количества битовых пакетов, переданных на ПК через USART
	InitUSART1();																							//Инициализация модуля USART1
	NVIC->ISER[0] |= 0x08000000; 															//Разрешение в NVIC прерывания от модуля USART1 	
	__enable_irq();																						//Глобальное разрешение прерываний 

	
	//Цикл выполняющий основную программу мигания свтодиода
	while(1){
		//Присваивание задержки исходя из данных массива хранящего задержку, от младшей цифры к старшей
		for (int32_t i = 5, j = 0; i >-1; i --, j++){
			delayCount = 0;																						//обнуление задержки
			delayCount += delayCountArr[i] * powi(10, (uint32_t)j);		//значение массива умножается на десять в степени равному разряду числа
		}
		GPIOB->BSRR= 0x1;																						//Зажечь светодиод, подключенный к выводу РВ.О
		delay(delayCount);																					//Задержка после включения светодиода
		GPIOB->BSRR=0x10000; 																				//Погасить светодиод, подключенный к выводу РВ.О
		delay (delayCount);																					//Задержка после выключения светодиода 
	}
}

//Функция инициализации USART лабораторного комплекса
void InitUSART1(){
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN;													//Включение тактирования USART1
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;														//Включение тактирования порта А
	
	//Настройка линий порта А: РА9(ТХ_1) - выход передатчика; PA10(RX_1) - вход приёмника
	GPIOA->MODER |= 0x00280000;																		//Перевести линии РА9 и РА10 в режим альтернативной функции
	GPIOA->AFR[1] |= 0x00000110;																	//Включить на линиях РА9 и РА10 альтернативную функцию AF1
	
	//Настройка линии передатчика Тх (РА9)
	GPIOA->OTYPER &= ~GPIO_OTYPER_OT_9;														//Сбросить 9 бит GPIOA->OTYPER - переключение в режим push-pull для линии РА9 (активный выход) 
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR9;														//Отключение подтягивающих резисторов для линии РА9 
	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEEDR9;											//Установка высокой скорости синхронизации линии РА9
	
	//Настройка линии приемника Rx (РА10)
	GPIOA->PUPDR &= ~GPIO_PUPDR_PUPDR10;													//Сброс режима подтягивающих резисторов для линии РА10
	GPIOA->PUPDR |= GPIO_PUPDR_PUPDR10_0;													//Включение подтягивающего резистора pull-up на входной линии РА10 (вход приемника Rx)
	
	//Конфигурирование USART
	USART1->CR1 &= ~USART_CR1_UE;																	//Запрещение работы модуля USART1 для изменения параметров его конфигурации
	USART1->BRR=69;																								/*Настройка делителя частоты, тактирующего USART и задающего скорость приема и передачи данных на уровне 115200 бит/с: 
																																	Частота тактирующего генератора = 8 МГц 
																																	Скорость обмена по USART - 115200 бит/с; коэффициент деления - 8000000 / 115200 - 69,4444(4); Округленное значение - 69*/
	USART1->CR1 = USART_CR1_TE | USART_CR1_RE;										/*Разрешить работу приемника и передатчика USART. Остальные биты этого регистра сброшены, что обеспечивает: 
																																	количество бит данных в пакете 8;
																																	контроль четности - отключен; 
																																	прерывания по любым флагам USART - запрещены;
																																	состояние USART - отключен*/
	USART1->CR1 |= USART_CR1_RXNEIE | USART_CR1_TCIE; 						/*Разрешение (в модуле USART1) на выдачу сигнала прерывания при возникновении событий:
																																	прием кадра в буферный регистр; завершение передачи кадра */
	USART1->CR2 = 0;																							//Количество стоповых бит - 1
	USART1->CR3 = 0;																							//DMA1 - отключен
	USART1->CR1 |= USART_CR1_UE;																	//По завершении конфигурирования USART разрешить его работу (биту UE регистра CR1 присвоить 1)
}

//Функция задержки: count - количество элементарных периодов задержки с длительностью примерно 2.5 мкс 
void delay(uint32_t counts)
{
	volatile uint32_t i;																				//объявляем неоптимизируемую переменную
	for (i=0;i<counts;i++);																			//Выполнение пустых циклов для реализации программной задержки
}

//Функция-обработчик прерывания от модуля USART1 
void USART1_IRQHandler(void)
{
	uint8_t pack;																								//Переменная хранящая принятый битовый пакет
	
		//массив для вывода сообщения: "Период мигания, мкс: "
	uint8_t textStatus[23] = {0xCF,0xE5,0xF0,0xE8,0xEE,0xE4,0x20,0xEC, 0xE8, 0xE3, 0xE0, 0xED, 0xE8, 0xFF, 0x2C, 0x20, 0xEC, 0xEA, 0xF1, 0x3A, 0x20};	
		//массив для вывода сообения: "Новое значение, мкс: "
	uint8_t textInput[22] = {0xD,0xA,0xCD,0xEE,0xE2,0xEE,0xE5,0x20, 0xE7, 0xED, 0xE0, 0xF, 0xE5, 0xED, 0xE8, 0xE5, 0x20, 0xEC, 0xEA, 0xF1, 0x3A, 0x20};	

	//Событие готовности принятых данных к чтению  
	if (USART1->ISR & USART_ISR_RXNE) { 												//Если в регистре состояний USART1 установлен флаг "RXNE", то
		pack=(uint8_t)USART1->RDR; 																//Чтение принятого битового пакета из буферного регистра приемника USART1 
		
		//Обработка на основе принятого пакета
		switch ( pack ) {
		case 0x0D:																								//При нажатии на enter
			if(flag == 0){																					//Если flag = 0, вывод текущеё задержки
				for(uint8_t i = 0; i<23; i++){												//Проход по массиву textStatus
						buf[(uint8_t)iReadyTX++] = textStatus[i];					//Добавление символа в буфер
				}
				for(uint8_t i = 0; i<6; i++){													//Проход по массиву хранщему задержку
					buf[(uint8_t)iReadyTX++] = (uint8_t)delayCountArr[i] + 48;	//Добавление задержки в буфер
				}
				for(uint8_t i = 0; i<22; i++){												//Проход по массиву textInput
					buf[(uint8_t)iReadyTX++] = textInput[i];						//Добавление символа в буфер
				}
				flag = 1;																							//Перевод flag в единцу --> принятие нового значения 
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			else{																										//Если flag не равен нулю
				flag = 0;																							//Обнуление flag
				updateDelay();																				//Обновление задержки
				buf[(uint8_t)iReadyTX++] = 0XD;												//Переход на новую строку
				buf[(uint8_t)iReadyTX++] = 0XA;												//Возврат каретки
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
			
		case 0x30:																								// При нажатии на ноль
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 0;															// Добавить в массив ввода 0							
				buf[(uint8_t)iReadyTX++] = 0x30;											// Добавление 0 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
			
		case 0x31:																								// При нажатии на 1
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 1;															// Добавить в массив ввода 1
				buf[(uint8_t)iReadyTX++] = 0x31;											// Добавление 1 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 0x32:																								// При нажатии на 2
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 2;															// Добавить в массив ввода 2
				buf[(uint8_t)iReadyTX++] = 0x32;											// Добавление 2 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 0x33:																								// При нажатии на 3
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 3;															// Добавить в массив ввода 3
				buf[(uint8_t)iReadyTX++] = 0x33;											// Добавление 3 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 0x34:																								// При нажатии на 4
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 4;															// Добавить в массив ввода 4
				buf[(uint8_t)iReadyTX++] = 0x34;											// Добавление 4 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 0x35:																								// При нажатии на 5
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 5;															// Добавить в массив ввода 5
				buf[(uint8_t)iReadyTX++] = 0x35;											// Добавление 5 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 0x36:																								// При нажатии на 6
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 6;															// Добавить в массив ввода 6
				buf[(uint8_t)iReadyTX++] = 0x36;											// Добавление 6 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 0x37:																								// При нажатии на 7
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 7;															// Добавить в массив ввода 7
				buf[(uint8_t)iReadyTX++] = 0x37;											// Добавление 7 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 0x38:																								// При нажатии на 8
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 8;															// Добавить в массив ввода 8
				buf[(uint8_t)iReadyTX++] = 0x38;											// Добавление 8 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 0x39:																								// При нажатии на 9
			if(count<5){																						// Если количество элементов меньше 5 (отсчёт с нуля)
				count++;																							// Увеличить счётчик переменных на единицу
				tempDelayArr[count] = 9;															// Добавить в массив ввода 9
				buf[(uint8_t)iReadyTX++] = 0x39;											// Добавление 9 в буфер
				outFirstChar();																				//Вызов функции выводящей первый символ буфера
			}
			break;																									//Выход из обработчика
		case 127:																									// При нажатии на backspace
			if(count > -1){																					// Если есть введённые переменные
				tempDelayArr[count] = 0;															// Добавить в массив ввода 0
				while ((USART1->ISR & USART_ISR_TXE) == 0) {}					// Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
				USART1->TDR = 127;																		// Удаление символа
				count--;																							// Уменьшить счётчик переменных на единицу
			}
			break;																									//Выход из обработчика
		}
	}
	
	//Событие завершение передачи битового пакета 
	if (USART1->ISR & USART_ISR_TC) {														//Если в регистре состояний USART1 установлен флаг "ТС", то
		// Сброс флага завершения передачи кадра 
		USART1->ICR=USART_ICR_TCCF;																//Сбросить флаг завершения передачи кадра, чтобы прерывание не сработало повторно
		//Если количество переданных данных меньше, чем количество подготовленных для передачи, то передать следующий битовой пакет из программного буфера в USART1 для отправки на ПК
		if (iCompleteTX<iReadyTX){
			USART1->TDR = buf[(uint8_t)iCompleteTX++];
		}
	}	
}


//powi функция для вычисления степени числа
//x - число которое нужно возвести в степень, n - степень в которую нужно возвести
//возвращает число возведённое в степень
uint32_t powi(uint32_t x, uint32_t n)
{
    if (n==0)																									//если степень равна 0
        return 1;																								//возвращается единица
    else if (n==1)																						//если степень равна 
			return x;																									//возвращается искомое число
    else if (n % 2 == 0 )																			//если степень чётная
			return powi( x * x, n/2);																	//производится рекурсия, передаётся число умноженное на себя и половина степени
    else																											//если степень нечётная
        return powi( x * x, n /2)*x;														//производится рекурсия, передаётся число умноженное на себя и половина степени
}		

//updateDelay функция обновления задержки
void updateDelay(){
	if(count > -1){																							// Если есть введённые цифры														
		for(uint8_t i = 0; i<6; i++){															// Проход по массиву задержки
			delayCountArr[i] = 0;																		// Обнуление массива
		}
		for(int8_t i = 5; i>=0; i--){															// Проход по массиву задержки, начиная от младшего элемнта
			delayCountArr[i] = tempDelayArr[count];									// Присваивание массиву задержки значений из массива ввода
			count--;																								// Уменьшить счётчик на 1
			if (count == -1){																				// Если счётчик равен -1
				break;																								// Выход из цикла
				}
		}
		for(uint8_t i = 0; i<6; i++){															// Проход по массиву ввода
			tempDelayArr[i] = 0;																		// Обнуление массива
		}
		count = -1;																								// Присваивание счётчику -1
	}	
}

//outFirstChar функция вывода символа в консоль
void outFirstChar(){
	while ((USART1->ISR & USART_ISR_TXE) == 0) {} 						//Дождаться готовности передатчика USART1 к приему битового пакета для отправки на ПК
	USART1->TDR = buf[(uint8_t)iCompleteTX++];								//Отправить старшую цифру ASCII-кода в передатчик USART1; 
																														//увеличить количество переданных на ПК данных на единицу
	}

/*----------------------------------------------------------------------------------------------------------------------------------------
**Руководство пользователя:
**		1. Запустите программу на лабораторном комплексе;
**		2. На компьютере запустите приложение PuTTY и подключитесь к соответствующему COM-порту на скорости 115200 бит/с;
** 		3. При активном окне терминала нажмите enter для вывода текущеё задержки и начала ввода новой, для активации новой задержки нажмите на enter;
**----------------------------------------------------------------------------------------------------------------------------------------*/
